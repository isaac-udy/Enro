package dev.enro.compiler.ir.transformers

import dev.enro.annotations.GeneratedNavigationBinding
import dev.enro.compiler.EnroNames
import dev.enro.compiler.ir.EnroSymbols
import dev.enro.compiler.ir.createIrBuilder
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.builders.irBlockBody
import org.jetbrains.kotlin.ir.builders.irCall
import org.jetbrains.kotlin.ir.builders.irString
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrConstructor
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrPackageFragment
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.callableId
import org.jetbrains.kotlin.ir.util.classId
import org.jetbrains.kotlin.ir.util.getAnnotationArgumentValue
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

class BindFunctionTransformer(
    private val pluginContext: IrPluginContext,
    private val enroSymbols: EnroSymbols,
) : IrElementTransformerVoid() {
    @OptIn(UnsafeDuringIrConstructionAPI::class)
    private val printlnFunction = pluginContext.referenceFunctions(
        CallableId(
            packageName = FqName("kotlin.io"),
            callableName = Name.identifier("println")
        )
    ).first {
        val params = it.owner.parameters
        params.size == 1 && params.single().type == pluginContext.irBuiltIns.anyNType
    }

    override fun visitFunction(declaration: IrFunction): IrStatement {
        generateBindingReferenceFunctionBody(declaration)?.let { return it }
        generateBindFunctionBody(declaration)?.let { return it }
        return declaration
    }

    private fun generateBindFunctionBody(declaration: IrFunction): IrStatement? {
        val parent = declaration.parent
        if (parent !is IrClass) return null
        if (parent.classId == null) return null
        if (declaration is IrConstructor) return null

        val bindFunctionId = EnroNames.Generated.bindFunction(parent.classId)
        if (bindFunctionId != declaration.callableId) return null

        val bindingData = GeneratedNavigationBindingData(
            pluginContext= pluginContext,
            bindingClass = parent,
        )

        return declaration.apply {
            declaration.body = pluginContext.createIrBuilder(declaration.symbol).irBlockBody {
                +irCall(
                    printlnFunction
                ).apply {
                    arguments[0] = irString("Saw binding type ${bindingData.bindingType} in ${declaration.callableId.classId} between ${bindingData.navigationKeyName} and ${bindingData.destinationName}")
                }
            }
        }
    }

    private fun generateBindingReferenceFunctionBody(declaration: IrFunction): IrStatement? {
        // The top-level functions generated by NavigationBindingGenerator (bindingReferenceFunction)
        // are used only for aggregating
        val parent = declaration.parent
        if (parent !is IrPackageFragment) return null
        if (declaration.callableId != EnroNames.Generated.bindingReferenceFunction) return null
        return declaration.apply {
            declaration.body = pluginContext.createIrBuilder(declaration.symbol).irBlockBody {}
        }
    }

    class GeneratedNavigationBindingData(
        private val pluginContext: IrPluginContext,
        private val bindingClass: IrClass,
    ) {
        val navigationKeyName = bindingClass.getAnnotationArgumentValue<String>(
            EnroNames.Annotations.generatedNavigationBinding.asSingleFqName(),
            GeneratedNavigationBinding::navigationKey.name
        ) ?: error("No navigationKeyName name found in $bindingClass")
        val destinationName = bindingClass.getAnnotationArgumentValue<String>(
            EnroNames.Annotations.generatedNavigationBinding.asSingleFqName(),
            GeneratedNavigationBinding::destination.name
        ) ?: error("No destination name found in $bindingClass")
        val bindingType = GeneratedNavigationBinding.BindingType.fromInt(
            value = bindingClass.getAnnotationArgumentValue<Int>(
                EnroNames.Annotations.generatedNavigationBinding.asSingleFqName(),
                GeneratedNavigationBinding::bindingType.name
            ) ?: -1
        )

        val navigationKeyClass by lazy {
            pluginContext.referenceClass(ClassId.fromString(navigationKeyName))
        }

        val destinationClass by lazy {
            if (bindingType !is  GeneratedNavigationBinding.BindingType.Class) return@lazy null
            pluginContext.referenceClass(ClassId.fromString(destinationName))
        }

        val destinationFunction by lazy {
            if (bindingType !is  GeneratedNavigationBinding.BindingType.Function) return@lazy null
            CallableId
            pluginContext.referenceFunctions(CallableId.fromString(destinationName)).single()
        }

        val destinationProperty by lazy {
            if (bindingType !is  GeneratedNavigationBinding.BindingType.Property) return@lazy null
            pluginContext.referenceProperties(CallableId.fromString(destinationName)).single()
        }
    }
}

fun CallableId.Companion.fromString(
    name: String,
): CallableId {
    val packageName = name.substringBeforeLast('/').replace('/', '.')
    val identifiers = name.substringAfterLast('/').split('.')

    val className = when {
        identifiers.size > 1 -> FqName(identifiers.dropLast(1).joinToString("."))
        else -> null
    }
    val referenceName = identifiers.last()

    return CallableId(
        packageName = FqName(packageName),
        className = className,
        callableName = Name.identifier(referenceName),
    )
}