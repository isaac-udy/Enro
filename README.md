[![Maven Central](https://img.shields.io/maven-central/v/dev.enro/enro.svg?label=Maven%20Central)](https://search.maven.org/search?q=g:%22dev.enro%22)

# Enro 🗺️
### [enro.dev](https://enro.dev)

**A declarative, type-safe navigation library for Kotlin Multiplatform**

Enro is a powerful navigation library built on a simple idea: screens should behave like functions.
Define a contract with parameters and optional results, navigate declaratively, and let Enro handle
the complexity.

Currently supporting: **Android** • **iOS** (experimental) • **Desktop** (experimental) • **Web/WASM
** (experimental)

## Why Enro?

- **🎯 Type-Safe Navigation** - NavigationKeys define screens like function signatures, with
  compile-time safety for parameters and results
- **🔄 Result Handling** - First-class support for screens that return results, with type-safe result
  channels
- **🎨 Compose-First** - Built for Jetpack/Multiplatform Compose, with support for Fragments and
  Activities on Android
- **🌐 Multiplatform Ready** - Shared navigation logic across all platforms with Kotlin Multiplatform
- **🎬 Scene-Based Rendering** - Automatic handling of dialogs, overlays, and multi-pane layouts with
  navigation scenes, built on familiar AndroidX Navigation3 concepts
- **🧩 Flexible Architecture** - Powerful features like navigation flows, interceptors, decorators,
  and container-based navigation

## Quick Start

### Installation

```kotlin
// build.gradle.kts
dependencies {
    implementation("dev.enro:enro:3.0.0-alpha05")
    ksp("dev.enro:enro-processor:3.0.0-alpha05")
}
```

### Setup

1. Define a NavigationComponent:

```kotlin
@NavigationComponent
object MyNavigationComponent : NavigationComponentConfiguration()
```

2. Install Enro in your application:

**Android:**

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        MyNavigationComponent.installNavigationController(this)
    }
}
```

**iOS, Desktop, Web:** See [Installation Guide](https://enro.dev/docs/installing-enro.html)

> **Note:** The `installNavigationController` function is generated by the annotation processor.
> After creating your `NavigationComponent`, you may need to compile/build your application once
> before the `installNavigationController` function becomes available.

## Core Concepts

### NavigationKeys

NavigationKeys are the contracts for your screens. They define the parameters required to open a
screen and optionally the result type it returns.

```kotlin
@Serializable
data class UserProfile(
    val userId: String
) : NavigationKey

@Serializable
data class SelectDate(
    val minDate: LocalDate? = null,
    val maxDate: LocalDate? = null,
) : NavigationKey.WithResult<LocalDate>
```

### NavigationDestinations

Create destinations for your NavigationKeys using Composables, Fragments, or Activities:

**Composable:**

```kotlin
@Composable
@NavigationDestination(UserProfile::class)
fun UserProfileScreen() {
    val navigation = navigationHandle<UserProfile>()
    
    // Access parameters
    Text("User: ${navigation.key.userId}")
    
    Button(onClick = { navigation.close() }) {
        Text("Close")
    }
}
```

**With Results:**

```kotlin
@Composable
@NavigationDestination(SelectDate::class)
fun DatePickerScreen() {
    val navigation = navigationHandle<SelectDate>()
    
    DatePicker(
        minDate = navigation.key.minDate,
        maxDate = navigation.key.maxDate,
        onDateSelected = { date ->
            navigation.complete(date) // Return the result
        }
    )
}
```

**As Dialog:**

```kotlin
@NavigationDestination(ConfirmDialog::class)
val confirmDialog = navigationDestination<ConfirmDialog>(
    metadata = { dialog() } // Renders as a dialog
) {
    AlertDialog(
        title = { Text("Confirm Action") },
        text = { Text(navigation.key.message) },
        onDismissRequest = { navigation.close() },
        confirmButton = {
            Button(onClick = { navigation.complete(true) }) {
                Text("Confirm")
            }
        }
    )
}
```

### Navigation

Navigate between screens using NavigationHandles:

```kotlin
@Composable
fun MyScreen() {
    val navigation = navigationHandle()
    
    // Open a screen
    Button(onClick = { 
        navigation.open(UserProfile(userId = "123"))
    }) {
        Text("Open Profile")
    }
}
```

### Result Handling

Register for results from other screens:

```kotlin
@Composable
fun MyScreen() {
    val selectDate = registerForNavigationResult<LocalDate>(
        onClosed = { /* User cancelled */ },
        onCompleted = { date ->
            // Use the selected date
        }
    )
    
    Button(onClick = {
        selectDate.open(SelectDate(maxDate = LocalDate.now()))
    }) {
        Text("Select Date")
    }
}
```

### Navigation Containers

Create nested navigation hierarchies with containers:

```kotlin
@Composable
fun MainScreen() {
    val container = rememberNavigationContainer(
        backstack = listOf(HomeScreen.asInstance()),
        emptyBehavior = EmptyBehavior.closeParent(),
        filter = accept { /* Define what this container accepts */ }
    )
    
    NavigationDisplay(container)
}
```

### Navigation Flows

Build multi-step flows with automatic backstack management:

```kotlin
class OnboardingViewModel : ViewModel() {
    private val navigation by navigationHandle<OnboardingFlow>()
    
    val flow by registerForFlowResult(
        flow = {
            val name = open(EnterName())
            val email = open(EnterEmail())
            val preferences = open(SelectPreferences())
            
            open(Summary(name, email, preferences))
        },
        onCompleted = {
            navigation.close()
        }
    )
}
```

## Advanced Features

- **Scenes** - Automatic handling of dialogs, bottom sheets, and multi-pane layouts
- **Interceptors** - Modify or intercept navigation operations globally
- **Decorators** - Wrap destinations with additional UI or behavior
- **Path-Based Navigation** - Deep linking and web URL support
- **Shared Element Transitions** - Smooth animations between screens
- **ViewModel Integration** - Scoped ViewModels with navigation awareness
- **Testing Support** - Comprehensive testing utilities via `enro-test`

## Documentation

- [Getting Started](https://enro.dev/docs/getting-started.html)
- [NavigationKeys](https://enro.dev/docs/navigation-keys.html)
- [NavigationDestinations](https://enro.dev/docs/navigation-destinations.html)
- [Navigation Flows](https://enro.dev/docs/navigation-flows.html)
- [FAQ](https://enro.dev/docs/frequently-asked-questions.html)
- [Changelog](./CHANGELOG.md)

## Applications Using Enro

<p align="center">
    <a href="https://www.splitwise.com/">
        <img width="100px" src="resources/splitwise-icon.png" alt="Splitwise" />
    </a>
   &nbsp;
   &nbsp;
    <a href="https://play.google.com/store/apps/details?id=com.beyondbudget">
        <img width="100px" src="resources/beyond-budget-icon.png" alt="Beyond Budget" />
    </a>
   &nbsp;
   &nbsp;
    <a href="https://play.google.com/store/apps/details?id=com.xero.touch">
        <img width="100px" src="resources/xero-logo.png" alt="Xero Accounting" />
    </a>
   &nbsp;
   &nbsp;
    <a href="https://play.google.com/store/apps/details?id=com.anz.lotus">
        <img width="100px" src="resources/anz-plus.png" alt="ANZ Plus" />
    </a>
</p>

## Migrating from 2.x

Enro 3.0 introduces Kotlin Multiplatform support and some API changes. Key changes:

- NavigationKeys now use `@Serializable` instead of `@Parcelize`
- `SupportsPush`/`SupportsPresent` interfaces have been removed (use `NavigationKey` or
  `NavigationKey.WithResult<T>`)
- Navigation is now unified through `open()` instead of separate `push()`/`present()` methods
- Scenes determine rendering behavior (dialogs, overlays, etc.) via metadata instead of interfaces

### Migration Support with `enro-compat`

The `enro-compat` module provides typealiases and back-ported functionality to help make migrating
from 2.x to 3.x easier, with minimal changes required for existing 2.x applications. Since Enro 2.x
was Android-only, the `enro-compat` module only supports the Android platform.

To use the compatibility layer:

```kotlin
dependencies {
    implementation("dev.enro:enro-compat:3.0.0-alpha05")
}
```

The Enro team is committed to making the migration process as smooth as possible. If you need
additional compatibility support or encounter migration challenges, please open a GitHub issue
with details about your use case, and we'll work to add the necessary compatibility features.

See the [CHANGELOG](./CHANGELOG.md) for a complete list of changes.

## License

```
Copyright 2022 Isaac Udy

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

---
